<div class="page-header">
    <h3>未来是fp的未来</h3>
</div>
<p>2004年之前，摩尔定律一直有效。每年我们的程序执行都会变得更快，我们不需要成为一个优秀的程序员，我们不需要掌握更优化的算法就能让程序一年比一年更快。</p>
<p>芯片越来越大，时钟速度越来越快，程序运行速度越来越快，每年大概以15%幅度的性能提升。到了2004年，这些现象终止了。</p>
<!--more-->
<p>芯片已经足够大，时钟的速率已经快到在一个时钟周期内时钟脉冲不能到达芯片的所有部分。电路设计开始改变。多核处理器出现。</p>
<p>从2004年开始，芯片的体积仍然在增大，但时钟的速率开始变小，每个芯片上的CPU数量开始增加。我们从每一个芯片只有一个超级处理器的时代进入到每个芯片有多个速度较慢、性能较弱的多核处理器时代。</p>
<p>由此开始，顺序执行的程序显得越来越慢，一年慢过一年，而并行执行的程序开始变得越来越快。问题是，根本没有并行执行的程序，有也是极少。</p>

<p>而Erlang是一种具有并发特征的编程语言，所以Erlang程序本质上在具有并行能力的计算机上运行时要比其它程序都快的多。</p>
<p>而唯一能阻挡它运行的更快的问题就是Erlang程序中可能存在一些必须顺序执行的瓶颈。并行程序中有需要顺序执行的部分，这正应验了Amdahl定律。</p>
<p>假设你的程序中有10%是需要顺序执行的(其余部分可以并行)，可以并行的部分的执行时间可以压缩近似0——只要有足够的可以并行的处理器。</p>
<p>但顺序执行部分的时间无法缩减。如果程序中含有10%的需要顺序执行的代码，你的程序执行速度最高能提高10倍。其中1/10的程序的速度永远无法提高，其它9/10的程序的执行时间可以缩减至接近0。</p>
<h3>来看看fp有哪些特性:</h3>
<ul>
    <li>程序完全基于函数编写出来,压根儿就没有对象这种东西</li>
    <li>通常来说,给定相同输入,这些函数将返回相同的值</li>
    <li>这些函数通常没有副作用，也就是说,它们不改变程序的状态</li>
    <li>任何变量都只能赋值一次</li>
</ul>
<p>以这种编程方式编出来的程序,正是为并发量身打造。</p>
<h3><strong>哪些方法最适用于并发？</strong></h3>
<h4>最常见的争议是：线程更好还是进程更好。</h4>
<p>一个进程有多个线程组成,进程有自己的资源,而线程虽有自己的执行路径,但在同一进程内,各线程资源共享。线程占用资源较少,所以理论上来说,使用线程可获得更优异的性能。</p>
<p>线程的缺点,在于资源共享可能导致复杂而有缺陷的实现。而且这种资源共享必须用并发锁来管理,这也会产生瓶颈。</p>
<p>然而Erlang另辟蹊径,它没有线程的概念,而是让进程尽可能的轻量级一些.Erlang奉行的哲学是轻量级进程,这使它摆脱了在共享资源和性能瓶颈的泥沼中艰难跋涉的困境。</p>
<p>Erlang简化了应用程序中多进程创建、管理和通信的过程。分布式消息传递成为基本的语言结构,因此锁机制不再必要,并发性能也大有长进。</p>
<h4>当然fp也有缺点.其最大缺点就是对程序员的不友好性,语法晦涩,导致目前还是oop语言的天下.</h4>
<p>价格随意. <img style="width: 30%" src="http://img.vim-cn.com/e4/613d5777df07d14a3214528a2b2eeeb74f603c.jpg "
              alt="支付宝二维码"></p>
